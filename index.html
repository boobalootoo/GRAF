<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Graffiti Game</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/tone"></script>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #hand {
            position: absolute;
            width: 130px;
            height: 170px;
            pointer-events: none;
            display: none;
            top: 0;
            left: 0;
            z-index: 10;
        }
    </style>
</head>
<body>
    <img id="hand" src="https://raw.githubusercontent.com/boobalootoo/HANDS/main/hand.png" alt="Hand" />
    <script>
        let scene, camera, renderer;
        let player, wall, box;
        let currentColor = "#ff0000";
        let isDrawing = false;
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let rotateLeft = false;
        let rotateRight = false;
        let rotateUp = false;
        let rotateDown = false;
        let rotationSpeed = 0.02;
        let cameraRotationY = 0;
        let cameraRotationX = 0;
        let sprayPoints = [];
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let cameraTarget = new THREE.Vector3();
        const targetDistance = 5;
        const sprayRadius = 0.1;
        let pointGeometry;
        let pointMaterial;
        let numPoints = 10;
        let spraySynth;
        let handElement;
        let pickedCylinder = null;
        let originalCylinderParent = null;
        let originalCylinderPosition = null;
        let cylinders = [];

        // Sound Effects (Tone.js)
        const soundFiles = {
            capOff: "https://boobalootoo.github.io/HANDS/200375__cbakos__spray-paint-cap-off.wav",
            spray: "https://boobalootoo.github.io/HANDS/460408__jay_you__spray-painting.wav",
            shake: "https://boobalootoo.github.io/HANDS/523005__dobroide__20200502spraycanshake.wav",
            drop: "https://boobalootoo.github.io/HANDS/700149__piotrkier__dropping-spray-paint-can.wav"
        };

        let soundEffects = {};
        let toneInitialized = false; // Flag to track Tone.js initialization
        let audioContext; // Declare audioContext

        function playSound(soundName) {
            if (toneInitialized && soundEffects[soundName]) {
                const source = audioContext.createBufferSource(); // Create source node
                source.buffer = soundEffects[soundName].buffer;       // Set buffer
                source.connect(audioContext.destination);             // Connect to destination
                source.start(0);                                   // Play immediately
            }
        }

        function playSpraySound() {
            if (toneInitialized && spraySynth) {
                spraySynth.triggerAttackRelease("C4", "16n");
            }
            playSound('spray');
        }

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            player = new THREE.Object3D();
            player.position.set(0, 1.5, 5);
            scene.add(player);

            camera.position.set(0, 1.5, 0);
            cameraTarget.set(0, 1.5, -5);
            camera.lookAt(cameraTarget);
            player.add(camera);

            let groundGeometry = new THREE.PlaneGeometry(100, 100);
            let groundMaterial = new THREE.MeshBasicMaterial({ color: 0x808080, side: THREE.DoubleSide });
            let ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            scene.add(ground);

            let wallGeometry = new THREE.PlaneGeometry(10, 5);
            let wallMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, side: THREE.DoubleSide });
            wall = new THREE.Mesh(wallGeometry, wallMaterial);
            wall.position.set(0, 2.5, -3);
            scene.add(wall);

            // Create geometry for the open-top box directly
            const boxWidth = 1;
            const boxHeight = 1;
            const boxDepth = 1;
            const brownColor = 0xA0522D;

            let openTopBoxGeometry = new THREE.BufferGeometry();
            const positions = [
                // Bottom face
                -boxWidth / 2, 0, -boxDepth / 2,
                boxWidth / 2, 0, -boxDepth / 2,
                boxWidth / 2, 0, boxDepth / 2,
                -boxWidth / 2, 0, boxDepth / 2,

                // Front face
                -boxWidth / 2, 0, boxDepth / 2,
                boxWidth / 2, 0, boxDepth / 2,
                boxWidth / 2, boxHeight, boxDepth / 2,
                -boxWidth / 2, boxHeight, boxDepth / 2,

                // Back face
                -boxWidth / 2, 0, -boxDepth / 2,
                boxWidth / 2, 0, -boxDepth / 2,
                boxWidth / 2, boxHeight, -boxDepth / 2,
                -boxWidth / 2, boxHeight, -boxDepth / 2,

                // Left face
                -boxWidth / 2, 0, -boxDepth / 2,
                -boxWidth / 2, boxHeight, -boxDepth / 2,
                -boxWidth / 2, boxHeight, boxDepth / 2,
                -boxWidth / 2, 0, boxDepth / 2,

                // Right face
                boxWidth / 2, 0, -boxDepth / 2,
                boxWidth / 2, boxHeight, -boxDepth / 2,
                boxWidth / 2, boxHeight, boxDepth / 2,
                boxWidth / 2, 0, boxDepth / 2,
            ];

            const indices = [
                0, 1, 2, 2, 3, 0,    // Bottom
                4, 5, 6, 6, 7, 4,    // Front
                8, 9, 10, 10, 11, 8, // Back
                12, 13, 14, 14, 15, 12, // Left
                16, 17, 18, 18, 19, 16  // Right
            ];

            openTopBoxGeometry.setIndex(indices);
            openTopBoxGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            openTopBoxGeometry.computeVertexNormals();

            let boxMaterial = new THREE.MeshBasicMaterial({ color: brownColor, side: THREE.DoubleSide });
            box = new THREE.Mesh(openTopBoxGeometry, boxMaterial);
            box.position.set(4, 0.5, -2);
            scene.add(box);

            // Add outline
            const outlineMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 });
            const outlineGeometry = new THREE.EdgesGeometry(openTopBoxGeometry);
            const outline = new THREE.LineSegments(outlineGeometry, outlineMaterial);
            box.add(outline);
            scene.add(box);

            const light = new THREE.PointLight(0xffffff, 1, 100);
            light.position.set(5, 5, 5);
            scene.add(light);

            pointGeometry = new THREE.PlaneGeometry(0.05, 0.05);
            pointMaterial = new THREE.MeshBasicMaterial({ color: currentColor });

            // Initialize Tone.js and set up audio context
            try {
                Tone.start();
                spraySynth = new Tone.Synth().toDestination();
                toneInitialized = true;
                audioContext = Tone.getContext().rawContext; // Get the raw AudioContext
            } catch (error) {
                console.error("Tone.js initialization error:", error);
                spraySynth = null;
                toneInitialized = false;
            }

            handElement = document.getElementById('hand');
            if (handElement) {
                handElement.style.display = 'block';
            }


            // Add cylinders to the scene
            const cylinderGeometry = new THREE.CylinderGeometry(0.2, 0.2, 1, 32);
            const materials = [0x00ff00, 0x0000ff, 0xff0000].map(color => new THREE.MeshBasicMaterial({ color }));

            for (let i = 0; i < 3; i++) {
                let cylinder = new THREE.Mesh(cylinderGeometry, materials[i]);
                cylinder.position.set(4 + (i * 0.2 - 0.2), 1.5, -2);
                scene.add(cylinder);
                cylinders.push(cylinder);
            }

            // Load sound effects
            if (toneInitialized) {
                for (const key in soundFiles) {
                    fetch(soundFiles[key])
                        .then(response => response.arrayBuffer())
                        .then(arrayBuffer => audioContext.decodeAudioData(arrayBuffer)) // Use audioContext
                        .then(audioBuffer => {
                            soundEffects[key] = { buffer: audioBuffer }; // Store as { buffer: AudioBuffer }
                        })
                        .catch(error => console.error(`Error loading sound ${key}:`, error));
                }
            }

            // Event Listeners
            document.addEventListener("keydown", (event) => {
                switch (event.key) {
                    case "w": moveForward = true; break;
                    case "s": moveBackward = true; break;
                    case "a": moveLeft = true; break;
                    case "d": moveRight = true; break;
                    case "ArrowLeft": rotateLeft = true; break;
                    case "ArrowRight": rotateRight = true; break;
                    case "ArrowUp": rotateUp = true; break;
                    case "ArrowDown": rotateDown = false; break;
                }
            });

            document.addEventListener("keyup", (event) => {
                switch (event.key) {
                    case "w": moveForward = false; break;
                    case "s": moveBackward = false; break;
                    case "a": moveLeft = false; break;
                    case "d": moveRight = false; break;
                    case "ArrowLeft": rotateLeft = false; break;
                    case "ArrowRight": rotateRight = false; break;
                    case "ArrowUp": rotateUp = false; break;
                    case "ArrowDown": rotateDown = false; break;
                }
            });

            document.addEventListener('mousemove', (e) => {
                if (isDrawing) {
                    spray(e.clientX, e.clientY);
                }
                updateHandPosition(e);
                mouse.set(
                    (e.clientX / window.innerWidth) * 2 - 1,
                    -(e.clientY / window.innerHeight) * 2 + 1
                );
            });

            document.addEventListener('mousedown', (e) => {
                if (e.button === 2) {  // Right click - now just prevents context menu
                    e.preventDefault();
                    return;
                }

                isDrawing = true;
                spray(e.clientX, e.clientY);
            });

            document.addEventListener('mouseup', (e) => {
                 if (e.button === 2 && pickedCylinder) {
                    // Keep cylinder in hand - don't release it yet.  Do nothing on right-click up.
                    return;
                }
                else {
                    isDrawing = false;
                }
            });

            document.addEventListener('dblclick', (e) => {
                e.preventDefault();
                handlePickupOrDrop(e);
            });

            document.addEventListener('mouseout', () => {
                isDrawing = false;
            });

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            animate();
        }

        function handlePickupOrDrop(event) {
            if (pickedCylinder) {
                pickedCylinder = null; // Drop the cylinder
                playSound('drop');
                return;
            }

            mouse.set(
                (event.clientX / window.innerWidth) * 2 - 1,
                -(event.clientY / window.innerHeight) * 2 + 1
            );
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(cylinders);

            if (intersects.length > 0) {
                pickedCylinder = intersects[0].object;
                playSound('capOff');
            }
        }

        function updateHandPosition(event) {
            if (!event) return;
            handElement.style.left = `${event.clientX - handElement.offsetWidth / 2}px`;
            handElement.style.top = `${event.clientY - handElement.offsetHeight / 2}px`;

             if (pickedCylinder) {
                let vector = new THREE.Vector3(
                    (event.clientX / window.innerWidth) * 2 - 1,
                    -(event.clientY / window.innerHeight) * 2 + 1,
                    0.5
                );
                vector.unproject(camera);
                let dir = vector.sub(camera.position).normalize();
                let distance = 2;
                let newPos = camera.position.clone().add(dir.multiplyScalar(distance));
                pickedCylinder.position.copy(newPos);
            }
        }

        function updatePlayerPosition() {
            let speed = 0.1;
            velocity.set(0, 0, 0);

            if (moveForward) velocity.z -= speed;
            if (moveBackward) velocity.z += speed;
            if (moveLeft) velocity.x -= speed;
            if (moveRight) velocity.x += speed;

            direction.copy(velocity).normalize();
            player.position.add(direction.multiplyScalar(speed));

            if (rotateLeft) {
                cameraRotationY += rotationSpeed;
            }
            if (rotateRight) {
                cameraRotationY -= rotationSpeed;
            }
            if (rotateUp) {
                cameraRotationX += rotationSpeed;
            }
            if (rotateDown) {
                cameraRotationX -= rotationSpeed;
            }

            player.rotation.y = cameraRotationY;
            cameraRotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraRotationX));
            camera.rotation.x = cameraRotationX;

            cameraTarget.copy(player.position);
            cameraTarget.x += Math.sin(cameraRotationY) * targetDistance;
            cameraTarget.z += Math.cos(cameraRotationY) * -targetDistance;
            cameraTarget.y += Math.sin(cameraRotationX) * targetDistance;
            camera.lookAt(cameraTarget);
        }

        function spray(x, y) {
            mouse.set(
                (x / window.innerWidth) * 2 - 1,
                -(y / window.innerHeight) * 2 + 1
            );
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(wall);

            if (intersects.length > 0) {
                const point = intersects[0].point;
                for (let i = 0; i < numPoints; i++) {
                    const offsetX = (Math.random() - 0.5) * sprayRadius;
                    const offsetY = (Math.random() - 0.5) * sprayRadius;
                    const offsetZ = (Math.random() - 0.5) * sprayRadius;
                    const sprayX = point.x + offsetX;
                    const sprayY = point.y + offsetY;
                    const sprayZ = point.z + offsetZ;

                    sprayPoints.push({ x: sprayX, y: sprayY, z: sprayZ, color: currentColor });
                }
                playSpraySound();
            }
        }

        function drawSpray() {
            sprayPoints.forEach(p => {
                const spraySquare = new THREE.Mesh(pointGeometry, pointMaterial);
                spraySquare.position.set(p.x, p.y, p.z);
                spraySquare.lookAt(camera.position);
                scene.add(spraySquare);
            });
            sprayPoints.length = 0;
        }

        function animate() {
            requestAnimationFrame(animate);
            updatePlayerPosition();
            updateHandPosition();
            drawSpray();
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
